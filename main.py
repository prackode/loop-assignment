# important utility module
import uuid
import os
import pytz
from datetime import datetime

# Use of Flask framework for the API
from flask import Flask, jsonify, request,send_file

# database interaction using SQLAlchemy module
from flask_sqlalchemy import SQLAlchemy

# data processing using Pandas module
import pandas as pd


app = Flask(__name__)

# Path for postgres database named 'loop' stored at local
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://postgres:root@localhost:5432/restaurant_db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Model definition for the three tables to be created
class Store(db.Model):
    __tablename__ = 'stores'
    id = db.Column(db.BigInteger, primary_key=True)
    timezone_str = db.Column(db.String, default='America/Chicago')
    business_hours = db.relationship('BusinessHours', backref='store', lazy=True)

    def __init__(self, id, timezone_str='America/Chicago'):
        self.id = id
        self.timezone_str = timezone_str

    def __repr__(self):
        return f'Store:{self.id} executed'

class BusinessHours(db.Model):
    __tablename__ = 'business_hours'
    id = db.Column(db.BigInteger, primary_key=True)
    store_id = db.Column(db.BigInteger, db.ForeignKey('stores.id'))
    day_of_week = db.Column(db.Integer)
    start_time_local = db.Column(db.Time)
    end_time_local = db.Column(db.Time)

    def __init__(self, store_id, day_of_week, start_time_local, end_time_local):
        if store_id not in [store.id for store in Store.query.all()]:
            store_id = None
        self.store_id = store_id
        self.day_of_week = day_of_week
        self.start_time_local = start_time_local
        self.end_time_local = end_time_local

    def __repr__(self):
        return f'BusinessHours: {self.store_id} {self.day_of_week} executed'


class Status(db.Model):
    __tablename__ = 'statuses'
    id = db.Column(db.BigInteger, primary_key=True)
    store_id = db.Column(db.BigInteger)
    timestamp_utc = db.Column(db.DateTime)
    status = db.Column(db.String)

    def __init__(self, store_id, timestamp_utc, status):
        self.store_id = store_id
        self.timestamp_utc = timestamp_utc
        self.status = status

    def __repr__(self):
        return f'Status: {self.store_id} {self.timestamp_utc} executed'


@app.route('/trigger_report')
def trigger_report():
    # using uuid module to generate random uuid to be used as report id
    report_id = str(uuid.uuid4())
    
    # start with report generation process
    generate_report(report_id)
    return jsonify(report_id=report_id)


@app.route('/get_report', methods=['POST'])
def get_report():
    # get report id from the user which was earlier generated by the system 
    report_id = request.json['report_id']
    report_file = f'report_{report_id}.csv'

    # if the report csv file has been created so it must be present at the location
    if os.path.isfile(report_file):
        return send_file(report_file, as_attachment=True)
    else:
        return jsonify(status='Running')

# get respective store data and convert it all into a csv report file for the user
def generate_report(report_id):
    stores = get_stores()
    max_timestamp_utc = get_max_timestamp_utc()
    report_data = []
    for store in stores:
        store_hours = get_store_hours(store)
        timezone = pytz.timezone(store.timezone_str)
        store_status = get_store_status(store.id, max_timestamp_utc)
        if store_status:
            last_status_time = store_status.timestamp_utc.astimezone(timezone)
            last_status = store_status.status
        else:
            last_status_time = None
            last_status = None
        report_data.append({'store_id': store.id, 'last_status_time': last_status_time, 'last_status': last_status, **store_hours})
    
    # report generation in a csv file
    report_df = pd.DataFrame(report_data)
    report_df['is_open'] = report_df.apply(lambda row_id: is_store_open_now(row_id), axis=1)
    report_df.to_csv(f'report_{report_id}.csv', index=False)
    
# hard coding the current timestamp to be the max timestamp in case status data is not present
def get_max_timestamp_utc():
    max_status = Status.query.order_by(Status.timestamp_utc.desc()).first()
    if max_status:
        return max_status.timestamp_utc
    else:
        return datetime.utcnow()

# get stores data from the 'stores' table
def get_stores():
    return Store.query.all()

# get store business hours in a dictionary
def get_store_hours(store):
    hours = {}
    if store.business_hours:
        for business_hour in store.business_hours:
            # getting the day name using datetime module as day_of_week is valued 0 to 7
            day_name = datetime.strptime(str(business_hour.day_of_week), '%w').strftime('%A')
            hours[f'{day_name}_open'] = business_hour.start_time_local.strftime('%H:%M')
            hours[f'{day_name}_close'] = business_hour.end_time_local.strftime('%H:%M')
    else:
        # assuming default business hours in case data is not present (default closing time should be taken as 23:59 but 24:00 has been taken for calculation convenience)
        hours = {
            'Monday_open': '00:00',
            'Monday_close': '24:00',
            'Tuesday_open': '00:00',
            'Tuesday_close': '24:00',
            'Wednesday_open': '00:00',
            'Wednesday_close': '24:00',
            'Thursday_open': '00:00',
            'Thursday_close': '24:00',
            'Friday_open': '00:00',
            'Friday_close': '24:00',
            'Saturday_open': '00:00',
            'Saturday_close': '24:00',
            'Sunday_open': '00:00',
            'Sunday_close': '24:00'
        }
    return hours

# check current status of the store using the Status table
def get_store_status(store_id, max_timestamp_utc):
    return Status.query.filter_by(store_id=store_id).filter(Status.timestamp_utc <= max_timestamp_utc).order_by(Status.timestamp_utc.desc()).first()

# check if the given store is currently open or not in comparison to cuurent time in timzone of the store
def is_store_open_now(store):
    now = datetime.now(pytz.timezone(store['timezone_str']))
    day_name = now.strftime('%A')
    start_time_str = store[f'{day_name}_open']
    end_time_str = store[f'{day_name}_close']
    if start_time_str and end_time_str:
        start_time = datetime.strptime(start_time_str, '%H:%M').time()
        end_time = datetime.strptime(end_time_str, '%H:%M').time()
        store_start_time = datetime.combine(now.date(), start_time, now.tzinfo)
        store_end_time = datetime.combine(now.date(), end_time, now.tzinfo)
        if store_start_time < now < store_end_time:
            return True
    return False

if __name__ == "__main__":
    # read all the csv files using Pandas and populate the data into respective tables using SQLAlchemy
    with app.app_context():
        db.create_all()
        # Using pandas module to convert store_status.csv into dataframe
        status_df = pd.read_csv('store_status.csv')

        # Convert the data frame into a list of dictionaries
        status_data = status_df.to_dict(orient='records')

        # Populate data into status table from the status_data dataframe
        for data in status_data:
            store_id = data.pop('store_id')
            timestamp_utc = datetime.strptime(data['timestamp_utc'].replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
            status = data['status']

            status_row = Status(store_id=store_id, timestamp_utc=timestamp_utc, status=status)
            db.session.add(status_row)


        # Using pandas module to convert business_hours.csv into dataframe
        hours_df = pd.read_csv('business_hours.csv')

        # Convert the data frame into a list of dictionaries
        hours_data = hours_df.to_dict(orient='records')

        # Populate data into business_hours table from the hours_data dataframe
        for data in hours_data:
            store_id = data.pop('store_id')
            day_of_week = data['day']
            start_time_local = datetime.strptime(data['start_time_local'], '%H:%M:%S').time()
            end_time_local = datetime.strptime(data['end_time_local'], '%H:%M:%S').time()

            hours_row = BusinessHours(store_id=store_id, day_of_week=day_of_week, start_time_local=start_time_local, end_time_local=end_time_local)
            db.session.add(hours_row)

        # Using pandas module to convert stores.csv into dataframe
        stores_df = pd.read_csv('stores.csv')

        # Convert the data frame into a list of dictionaries
        stores_data = stores_df.to_dict(orient='records')

        # Populate data into stores table from the stores dataframe
        for data in stores_data:
            store_id = data.pop('store_id')
            timezone_str = data['timezone_str']

            store_row = Store(id=store_id, timezone_str=timezone_str)
            db.session.add(store_row)

        # Commit the changes to the database
        db.session.commit()
        
    app.run(debug=True)